<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>whowechina Series Controller Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            position: relative;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
        }
        .lang-switch {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .lang-btn {
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            background-size: cover;
            background-position: center;
            border-radius: 5px;
            padding: 0;
        }
        .lang-btn.lang-en-btn {
            background-image: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 190 100"%3E%3Cg%3E%3Crect width="190" height="7.69" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="7.69" fill="white"/%3E%3Crect width="190" height="7.69" y="15.38" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="23.07" fill="white"/%3E%3Crect width="190" height="7.69" y="30.76" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="38.45" fill="white"/%3E%3Crect width="190" height="7.69" y="46.14" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="53.83" fill="white"/%3E%3Crect width="190" height="7.69" y="61.52" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="69.21" fill="white"/%3E%3Crect width="190" height="7.69" y="76.9" fill="%23B22234"/%3E%3Crect width="190" height="7.69" y="84.59" fill="white"/%3E%3Crect width="190" height="7.69" y="92.28" fill="%23B22234"/%3E%3Crect width="76" height="53.85" fill="%233C3B6E"/%3E%3C/g%3E%3C/svg%3E');
        }
        .lang-btn.lang-zh-btn {
            background-image: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 200"%3E%3Crect width="300" height="200" fill="%23de2910"/%3E%3Cg fill="%23ffde00"%3E%3Cpath d="M60,30 l20,60 l-50,-40 h62 l-50,40 z"/%3E%3Cpath d="M120,10 l5,15 l-12,-10 h15 l-12,10 z"/%3E%3Cpath d="M140,25 l5,15 l-12,-10 h15 l-12,10 z"/%3E%3Cpath d="M140,50 l5,15 l-12,-10 h15 l-12,10 z"/%3E%3Cpath d="M120,65 l5,15 l-12,-10 h15 l-12,10 z"/%3E%3C/g%3E%3C/svg%3E');
        }
        .lang-btn:hover {
            opacity: 0.8;
            transform: scale(1.05);
            border-color: #007bff;
        }
        .lang-btn.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        }
        .lang-en { display: inline; }
        .lang-zh { display: none; }
        body.zh .lang-en { display: none; }
        body.zh .lang-zh { display: inline; }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 5px;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        .reset-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
        }
        .reset-btn:hover {
            background-color: #c82333;
        }
        .gamepad {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .gamepad-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: flex-start;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .button-circle {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e9ecef, #ffffff);
            border: 3px solid #dee2e6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.066s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .button-circle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .button-circle.pressed {
            background: linear-gradient(145deg, #28a745, #34ce57);
            border-color: #1e7e34;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
        }
        .button-name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 3px;
            text-align: center;
            line-height: 1;
        }
        .button-count {
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
        }
        .button-circle.pressed .button-count {
            color: white;
        }
        /* ç‰¹æ®ŠæŒ‰é’®é¢œè‰² */
        .button-circle.action {
            background: linear-gradient(145deg, #ffeaa7, #fdcb6e);
            border-color: #e17055;
        }
        .button-circle.shoulder {
            background: linear-gradient(145deg, #a29bfe, #6c5ce7);
            color: white;
        }
        .button-circle.dpad {
            background: linear-gradient(145deg, #fd79a8, #e84393);
            color: white;
        }
        .button-circle.system {
            background: linear-gradient(145deg, #636e72, #2d3436);
            color: white;
        }
        .axes-section {
            margin-top: 20px;
        }
        .axes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
            gap: 10px;
        }
        .axis-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }
        .axis-name {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 12px;
        }
        .axis-value {
            font-size: 11px;
            font-family: monospace;
            margin-top: 5px;
            color: #495057;
        }
        .axis-bar {
            width: 35%;
            height: 100px;
            background: linear-gradient(to bottom, #e9ecef 0%, #f8f9fa 50%, #e9ecef 100%);
            border: 1px solid #ced4da;
            border-radius: 4px;
            position: relative;
            margin: 5px auto;
        }
        .axis-indicator {
            position: absolute;
            width: 200%;
            height: 6px;
            background: #007bff;
            border-radius: 3px;
            box-shadow: 0 0 4px rgba(0, 123, 255, 0.5);
            left: -50%;
            z-index: 10;
        }
        .axis-trail {
            position: absolute;
            width: 200%;
            height: 4px;
            background: #007bff;
            border-radius: 2px;
            left: -50%;
            pointer-events: none;
            transition: opacity 0.6s ease;
        }
        .axis-center-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #6c757d;
            transform: translateY(-50%);
        }

        .stick-2d {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            grid-column: span 2;
        }
        .stick-2d-canvas {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #e9ecef 0%, #f8f9fa 100%);
            border: 2px solid #ced4da;
            border-radius: 50%;
            position: relative;
            margin: 5px auto;
        }
        .stick-2d-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background: #6c757d;
            transform: translate(-50%, -50%);
        }
        .stick-2d-cross-h {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #adb5bd;
            transform: translateY(-50%);
        }
        .stick-2d-cross-v {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #adb5bd;
            transform: translateX(-50%);
        }
        .stick-2d-indicator {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #007bff;
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.6);
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .stick-2d-trail {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #007bff;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: opacity 0.6s ease;
        }
        .stick-2d-value {
            font-size: 11px;
            font-family: monospace;
            margin-top: 5px;
            color: #495057;
        }

        .button-group {
            margin-bottom: 20px;
        }
        .button-group-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            text-align: left;
        }

        /* HID LED æ§åˆ¶é¢æ¿æ ·å¼ */
        .hid-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .hid-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #ffc107;
            padding-bottom: 10px;
        }
        .hid-status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }
        .hid-status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        .hid-status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .hid-connect-btn {
            display: block;
            margin: 0 auto 15px;
            background-color: #ffc107;
            color: #333;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
        }
        .hid-connect-btn:hover {
            background-color: #e0a800;
        }
        .led-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .led-button {
            width: 72px;
            height: 72px;
            border-radius: 8px;
            border: 3px solid #343a40;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            /* åªå¯¹ transform æ·»åŠ è¿‡æ¸¡ï¼Œä¸åŒ…æ‹¬ box-shadowï¼ˆå…‰æ™•ï¼‰ */
            transition: transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
        }
        /* å½¢çŠ¶å˜ä½“ */
        .led-button.shape-circle {
            border-radius: 50%;
        }
        .led-button.shape-square {
            border-radius: 8px;
        }
        .led-button.shape-portrait {
            border-radius: 8px;
        }
        .led-button.shape-landscape {
            border-radius: 8px;
        }
        .led-button.rgb-type {
            position: relative;
            padding: 5px; /* ä¸Šä¸‹å·¦å³å®Œå…¨å¯¹ç§°ï¼Œä¿æŒåœ†å½¢ */
        }
        .led-button.rgb-type .led-name {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
        }
        .led-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        .led-button.rgb-type:hover {
            transform: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .led-button.on {
            background: linear-gradient(145deg, #ffc107, #ff9800);
            border-color: #ff6f00;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.6), 0 4px 8px rgba(0,0,0,0.2);
            color: #000;
        }
        .led-button.dragging {
            cursor: ns-resize;
            /* æ‹–æ‹½æ—¶ç»´æŒæ‚¬åœæ•ˆæœ */
            transform: translateY(-2px);
        }
        .brightness-indicator {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            background: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            pointer-events: none;
            margin: 0;
        }
        .led-icon {
            font-size: 29px;
            margin: 0 0 2px 0;
        }
        .led-name {
            font-size: 11px;
            line-height: 1;
            word-wrap: break-word;
            margin: 0 0 2px 0;
            font-weight: bold;
        }
        .rgb-sliders {
            display: flex;
            justify-content: center;
            align-items: stretch;
            width: 75%;
            height: 60%;
            margin-left: auto;
            margin-right: auto;
            margin-top: calc(50% - 30% - 6px); /* 50%æ˜¯ä¸­å¿ƒï¼Œ-30%æ˜¯å®¹å™¨åŠé«˜ï¼Œ-6pxæ˜¯æ ‡é¢˜åŠé«˜ */
            flex-direction: column;
        }
        .rgb-sliders-row {
            display: flex;
            justify-content: space-between;
            height: 100%;
            width: 100%;
        }
        .rgb-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            margin: 0 2%;
        }
        .rgb-slider-title {
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 2px;
            color: #666;
        }
        .rgb-slider {
            width: 100%;
            flex: 1;
            background: linear-gradient(to top, #333, #666);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .rgb-slider-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            border-radius: 3px;
        }
        .rgb-slider.r .rgb-slider-fill {
            background: linear-gradient(to top, #000, #f00);
        }
        .rgb-slider.g .rgb-slider-fill {
            background: linear-gradient(to top, #000, #0f0);
        }
        .rgb-slider.b .rgb-slider-fill {
            background: linear-gradient(to top, #000, #00f);
        }
        .rgb-slider-value {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            background: rgba(0,0,0,0.6);
            padding: 1px 4px;
            border-radius: 2px;
            color: white;
            font-weight: bold;
            pointer-events: none;
            min-width: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="lang-switch">
            <button class="lang-btn lang-en-btn active" id="lang-en" onclick="switchLanguage('en')" title="English"></button>
            <button class="lang-btn lang-zh-btn" id="lang-zh" onclick="switchLanguage('zh')" title="ä¸­æ–‡"></button>
        </div>
        <h1>ğŸ® <span class="lang-en"><a href="https://github.com/whowechina" target="_blank" style="color: inherit; text-decoration: none;">whowechina</a> Series Controller Test</span><span class="lang-zh"><a href="https://github.com/whowechina" target="_blank" style="color: inherit; text-decoration: none;">whowechina</a> ç³»åˆ—æ‰‹å°æµ‹è¯•</span></h1>
        <div id="status" class="status disconnected">
            <span class="lang-en">Please connect a gamepad and press any button to activate</span><span class="lang-zh">è¯·è¿æ¥æ¸¸æˆæ‰‹æŸ„å¹¶æŒ‰ä»»æ„æŒ‰é’®æ¿€æ´»</span>
        </div>

        <div id="gamepads"></div>

        <!-- HID LED æ§åˆ¶é¢æ¿ -->
        <div class="hid-panel">
            <div class="hid-title">ğŸ’¡ <span class="lang-en">HID Light Control</span><span class="lang-zh">HID ç¯å…‰æ§åˆ¶</span></div>
            <div id="hid-status" class="hid-status disconnected">
                <span class="lang-en">Click button to connect HID device</span><span class="lang-zh">ç‚¹å‡»æŒ‰é’®è¿æ¥ HID è®¾å¤‡</span>
            </div>
            <button class="hid-connect-btn" id="hid-connect-btn" onclick="toggleHIDConnection()">ğŸ”Œ <span class="lang-en">Connect HID Device</span><span class="lang-zh">è¿æ¥ HID è®¾å¤‡</span></button>
            <div class="led-grid" id="led-container">
                <!-- LED æŒ‰é’®å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        // è¯­è¨€åˆ‡æ¢
        function switchLanguage(lang) {
            if (lang === 'zh') {
                document.body.classList.add('zh');
                document.getElementById('lang-en').classList.remove('active');
                document.getElementById('lang-zh').classList.add('active');
            } else {
                document.body.classList.remove('zh');
                document.getElementById('lang-en').classList.add('active');
                document.getElementById('lang-zh').classList.remove('active');
            }
        }

        // å…¨å±€çŠ¶æ€
        let gamepads = {};
        let buttonStates = {};
        let buttonCounts = {};
        let stickTrails = {}; // å­˜å‚¨æ‘‡æ†æ‹–å°¾å†å²
        let isGamepadSupported = 'getGamepads' in navigator;

        // HID ç›¸å…³å˜é‡
        let hidDevice = null;
        let ledStates = {}; // å­˜å‚¨æ¯ä¸ª LED çš„çŠ¶æ€
        let outputReportId = 0;
        let outputReportSize = 0;
        let hidUpdateTimer = null; // å®šæœŸå‘é€å®šæ—¶å™¨
        let currentLedMapping = null; // å½“å‰è®¾å¤‡çš„LEDæ˜ å°„é…ç½®

        // LED æ˜ å°„é…ç½® - æ ¹æ®è®¾å¤‡åç§°å®šä¹‰ç¯å…‰å¸ƒå±€
        const ledMappingConfig = {
            "IIDX Pico Controller": {
                lights: [
                    { name: "E1", index: 7, x: 10, y: 8, color: "red", shape: "square", size: 50},
                    { name: "E2", index: 8, x: 20, y: 8, color: "green", shape: "square", size: 50},
                    { name: "E3", index: 9, x: 30, y: 8, color: "green", shape: "square", size: 50},
                    { name: "E4", index: 10, x: 40, y: 8, color: "green", shape: "square", size: 50},
    
                    { name: "B2", index: 1, x: 14, y: 28, color: "blue", shape: "portrait", size: 95},
                    { name: "B4", index: 3, x: 26, y: 28, color: "blue", shape: "portrait", size: 95},
                    { name: "B6", index: 5, x: 38, y: 28, color: "blue", shape: "portrait", size: 95},
    
                    { name: "B1", index: 0, x: 9, y: 43, color: "white", shape: "portrait", size: 95},
                    { name: "B3", index: 2, x: 21, y: 43, color: "white", shape: "portrait", size: 95},
                    { name: "B5", index: 4, x: 33, y: 43, color: "white", shape: "portrait", size: 95},
                    { name: "B7", index: 6, x: 45, y: 43, color: "white", shape: "portrait", size: 95},
    
                    { name: "TT", index: 11, x: 72, y: 28, color: "rgb", shape: "circle", size: 300},
                ]
            },
            "AIC Pico LED": {
                lights: [
                    { name: "AIC Pico", index: 0, x: 15, y: 15, color: "rgb", shape: "circle", size: 200 }
                ]
            },
            "Popn Pico": {
                lights: [
                    { name: "B2", index: 1, x: 14, y: 8, color: "yellow", shape: "circle", size: 95},
                    { name: "B4", index: 3, x: 29, y: 8, color: "blue", shape: "circle", size: 95},
                    { name: "B6", index: 5, x: 44, y: 8, color: "blue", shape: "circle", size: 95},
                    { name: "B8", index: 7, x: 59, y: 8, color: "yellow", shape: "circle", size: 95},
    
                    { name: "B1", index: 0, x: 9, y: 23, color: "white", shape: "circle", size: 95},
                    { name: "B3", index: 2, x: 24, y: 23, color: "green", shape: "circle", size: 95},
                    { name: "B5", index: 4, x: 39, y: 23, color: "red", shape: "circle", size: 95},
                    { name: "B7", index: 6, x: 54, y: 23, color: "green", shape: "circle", size: 95},
                    { name: "B9", index: 8, x: 69, y: 23, color: "white", shape: "circle", size: 95},

                    { name: "Cabnet", index: 9, x: 88, y: 15, color: "rgb", shape: "portrait", size: 200},
                ]
            },
            // å¯ä»¥åœ¨æ­¤æ·»åŠ æ›´å¤šè®¾å¤‡çš„é…ç½®
            // æ”¯æŒçš„å½¢çŠ¶: "square" (æ­£æ–¹å½¢), "circle" (åœ†å½¢), "portrait" (ç«–é•¿æ–¹å½¢), "landscape" (æ¨ªé•¿æ–¹å½¢)
            // size: ç¼©æ”¾å› å­ï¼Œé»˜è®¤100ï¼ŒåŸºç¡€å¤§å°ä¸ºå®¹å™¨å®½åº¦çš„10%ï¼Œsize=100å³10%ï¼Œsize=50å³5%ï¼Œsize=200å³20%
            // x: æ¨ªå‘ä½ç½®ï¼ŒèŒƒå›´0-100ï¼Œ0ä¸ºæœ€å·¦ï¼Œ100ä¸ºæœ€å³ï¼ˆç™¾åˆ†æ¯”ï¼‰
            // y: çºµå‘ä½ç½®ï¼ŒèŒƒå›´0-100ï¼Œç›¸å¯¹äºå®¹å™¨å®½åº¦è®¡ç®—ï¼ˆä¿æŒ1:1å®½é«˜æ¯”ï¼‰
        };

        // åˆå§‹åŒ–
        if (!isGamepadSupported) {
            document.getElementById('status').innerHTML = '<span class="lang-en">Your browser does not support Gamepad API</span><span class="lang-zh">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Gamepad API</span>';
            document.getElementById('status').className = 'status disconnected';
        }

        // æ£€æŸ¥ WebHID æ”¯æŒ
        if (!('hid' in navigator)) {
            const hidStatus = document.getElementById('hid-status');
            hidStatus.innerHTML = '<span class="lang-en">WebHID API not supported</span><span class="lang-zh">ä¸æ”¯æŒ WebHID API</span>';
            hidStatus.className = 'hid-status disconnected';
        }

        // ========== HID åŠŸèƒ½ ==========
        
        function toggleHIDConnection() {
            if (hidDevice) {
                disconnectHIDDevice();
            } else {
                connectHIDDevice();
            }
        }

        function disconnectHIDDevice() {
            if (!hidDevice) return;
            
            // æ¸…é™¤å®šæ—¶å™¨
            if (hidUpdateTimer) {
                clearInterval(hidUpdateTimer);
                hidUpdateTimer = null;
            }
            
            hidDevice.close();
            hidDevice = null;
            ledStates = {};
            
            // æ›´æ–°çŠ¶æ€
            document.getElementById('hid-status').innerHTML = 
                '<span class="lang-en">Click button to connect HID device</span><span class="lang-zh">ç‚¹å‡»æŒ‰é’®è¿æ¥ HID è®¾å¤‡</span>';
            document.getElementById('hid-status').className = 'hid-status disconnected';
            
            // æ¸…ç©ºLEDå®¹å™¨å¹¶é‡ç½®é«˜åº¦
            const container = document.getElementById('led-container');
            container.innerHTML = '';
            container.style.minHeight = '';
            
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            document.getElementById('hid-connect-btn').innerHTML = 
                'ğŸ”Œ <span class="lang-en">Connect HID Device</span><span class="lang-zh">è¿æ¥ HID è®¾å¤‡</span>';
        }
        
        async function connectHIDDevice() {
            try {
                const devices = await navigator.hid.requestDevice({ filters: [] });
                
                if (devices.length === 0) {
                    return;
                }

                hidDevice = devices[0];
                await hidDevice.open();
                
                console.log('HID Device connected:', hidDevice);
                
                // è·å–è®¾å¤‡åç§°å¹¶æŸ¥æ‰¾æ˜ å°„é…ç½®
                const deviceName = hidDevice.productName || 'HID Device';
                console.log('Device productName:', JSON.stringify(deviceName));
                console.log('Available mappings:', Object.keys(ledMappingConfig));
                
                currentLedMapping = ledMappingConfig[deviceName] || null;
                
                if (currentLedMapping) {
                    console.log('âœ… Found LED mapping for device:', deviceName);
                } else {
                    console.log('âš ï¸ No LED mapping found for device:', deviceName);
                    console.log('Using default layout');
                }
                
                // è§£æ Output Report
                parseOutputReports();
                
                // æ›´æ–°çŠ¶æ€
                document.getElementById('hid-status').innerHTML = 
                    `âœ… <span class="lang-en">Connected: ${deviceName}</span><span class="lang-zh">å·²è¿æ¥: ${deviceName}</span>`;
                document.getElementById('hid-status').className = 'hid-status connected';
                
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬
                document.getElementById('hid-connect-btn').innerHTML = 
                    'ğŸ”Œ <span class="lang-en">Disconnect</span><span class="lang-zh">æ–­å¼€</span>';
                
                // å¯åŠ¨å®šæ—¶å‘é€ï¼Œæ¯250msï¼ˆæ¯ç§’4æ¬¡ï¼‰
                if (hidUpdateTimer) clearInterval(hidUpdateTimer);
                hidUpdateTimer = setInterval(() => {
                    if (hidDevice) {
                        sendOutputReport();
                    }
                }, 250);

                // ç›‘å¬æ–­å¼€
                hidDevice.addEventListener('disconnect', () => {
                    // æ¸…é™¤å®šæ—¶å™¨
                    if (hidUpdateTimer) {
                        clearInterval(hidUpdateTimer);
                        hidUpdateTimer = null;
                    }
                    
                    document.getElementById('hid-status').innerHTML = 
                        '<span class="lang-en">Device disconnected</span><span class="lang-zh">è®¾å¤‡å·²æ–­å¼€</span>';
                    document.getElementById('hid-status').className = 'hid-status disconnected';
                    document.getElementById('led-container').innerHTML = '';
                    hidDevice = null;
                    ledStates = {};
                    
                    // æ›´æ–°æŒ‰é’®æ–‡æœ¬
                    document.getElementById('hid-connect-btn').innerHTML = 
                        'ğŸ”Œ <span class="lang-en">Connect HID Device</span><span class="lang-zh">è¿æ¥ HID è®¾å¤‡</span>';
                });

            } catch (error) {
                console.error('HID connection error:', error);
                const isZh = document.body.classList.contains('zh');
                alert(isZh ? `è¿æ¥å¤±è´¥: ${error.message}` : `Failed to connect HID device: ${error.message}`);
            }
        }

        function parseOutputReports() {
            const container = document.getElementById('led-container');
            container.innerHTML = '';
            ledStates = {};

            let ledIndex = 0;

            hidDevice.collections.forEach((collection) => {
                if (!collection.outputReports || collection.outputReports.length === 0) {
                    return;
                }

                collection.outputReports.forEach((report) => {
                    outputReportId = report.reportId;
                    
                    if (!report.items || report.items.length === 0) {
                        return;
                    }

                    // è®¡ç®—æŠ¥å‘Šæ€»å¤§å°
                    let totalBits = 0;
                    report.items.forEach(item => {
                        totalBits += (item.reportSize || 0) * (item.reportCount || 1);
                    });
                    outputReportSize = Math.ceil(totalBits / 8);

                    // åˆå§‹åŒ–æ‰€æœ‰LEDçŠ¶æ€ä¸º0
                    for (let i = 0; i < outputReportSize; i++) {
                        ledStates[i] = 0;
                    }
                });
            });

            // ä½¿ç”¨æ˜ å°„é…ç½®åˆ›å»ºLEDæŒ‰é’®
            console.log('Checking mapping:', currentLedMapping);
            console.log('Has lights?', currentLedMapping && currentLedMapping.lights);
            
            // å°†å®¹å™¨è®¾ç½®ä¸ºç›¸å¯¹å®šä½ï¼Œç”¨äºç»å¯¹å®šä½æŒ‰é’®ï¼ˆå¯¹æ‰€æœ‰æƒ…å†µéƒ½éœ€è¦ï¼‰
            container.style.position = 'relative';
            
            // è®¾ç½®CSSå˜é‡å­˜å‚¨å®¹å™¨å®½åº¦ï¼Œç”¨äºåæ ‡è®¡ç®—ï¼ˆå¯¹æ‰€æœ‰æƒ…å†µéƒ½éœ€è¦ï¼‰
            const updateContainerWidth = () => {
                const width = container.offsetWidth;
                container.style.setProperty('--container-width', `${width}px`);
            };
            updateContainerWidth();
            window.addEventListener('resize', updateContainerWidth);
            
            if (currentLedMapping && currentLedMapping.lights) {
                console.log('ğŸ¨ Applying LED mapping with', currentLedMapping.lights.length, 'lights');
                console.log('Lights data:', currentLedMapping.lights);
                
                // è®¡ç®—æ‰€éœ€çš„æœ€å°é«˜åº¦ï¼ˆæ‰¾åˆ°Y+æŒ‰é’®é«˜åº¦çš„æœ€å¤§å€¼ï¼‰
                const calculateMinHeight = () => {
                    let maxBottom = 0;
                    currentLedMapping.lights.forEach((led) => {
                        const basePercent = 10;
                        const actualSize = basePercent * (led.size || 100) / 100;
                        let heightSize = actualSize;
                        
                        if (led.shape === 'landscape') {
                            heightSize = actualSize * 5 / 8;
                        }
                        
                        const y = led.y || 0;
                        const bottom = y + heightSize;
                        maxBottom = Math.max(maxBottom, bottom);
                    });
                    
                    // åŠ ä¸Šä½™é‡ï¼ˆé¢å¤–5%çš„é«˜åº¦ï¼‰
                    const minHeight = (maxBottom + 5) * container.offsetWidth / 100;
                    container.style.minHeight = `${minHeight}px`;
                };
                
                // åˆå§‹è®¡ç®—å’Œç›‘å¬çª—å£å˜åŒ–
                setTimeout(calculateMinHeight, 0);
                window.addEventListener('resize', calculateMinHeight);
                
                try {
                    currentLedMapping.lights.forEach((led, ledIndex) => {
                        console.log('Creating LED', ledIndex, ':', led);
                        
                        // å¤„ç†countå±æ€§ï¼Œåˆ›å»ºå¤šä¸ªè¿ç»­çš„LED
                        const count = led.count || 1;
                        const dx = led.dx !== undefined ? led.dx : (led.x || 0) * 0.1;
                        const dy = led.dy !== undefined ? led.dy : (led.y || 0) * 0.1;
                        
                        for (let i = 0; i < count; i++) {
                            // è®¡ç®—å½“å‰LEDçš„å±æ€§
                            let currentIndex = Array.isArray(led.index) 
                                ? led.index.map(idx => idx + i * (led.color === 'rgb' ? 3 : 1))
                                : led.index + i;
                            const currentName = count > 1 ? `${led.name} ${i + 1}` : led.name;
                            const currentX = (led.x || 0) + i * dx;
                            const currentY = (led.y || 0) + i * dy;
                            
                            if (led.color === 'rgb') {
                                // RGB ç±»å‹ï¼šç¡®ä¿indexæ˜¯æ•°ç»„
                                if (!Array.isArray(currentIndex)) {
                                    currentIndex = [currentIndex, currentIndex + 1, currentIndex + 2];
                                }
                                
                                // åˆ›å»ºä¸€ä¸ªæŒ‰é’®ï¼Œæ§åˆ¶ä¸‰ä¸ªé€šé“
                                const button = createLEDButton(
                                    currentIndex, // ä¼ é€’æ•´ä¸ªæ•°ç»„
                                    currentName, 
                                    'rgb', 
                                    null, 
                                    currentName, 
                                    led.shape, 
                                    false, 
                                    led.size, 
                                    currentX, 
                                    currentY
                                );
                                console.log('  Created RGB button:', currentName, 'with index', currentIndex);
                                
                                if (button) {
                                    container.appendChild(button);
                                    updateLEDVisual(currentIndex, 'rgb', null);
                                }
                            } else {
                                // æ™®é€šå•è‰²LED
                                const button = createLEDButton(
                                    currentIndex, 
                                    currentName, 
                                    led.color || 'white', 
                                    null, 
                                    null, 
                                    led.shape, 
                                    false, 
                                    led.size, 
                                    currentX, 
                                    currentY
                                );
                                console.log('  Created', led.color || 'white', 'button:', currentName);
                                
                                if (button) {
                                    container.appendChild(button);
                                    updateLEDVisual(currentIndex, led.color || 'white', null);
                                }
                            }
                        }
                    });
                    
                    console.log('âœ… LED mapping applied, total lights:', container.children.length);
                } catch (error) {
                    console.error('Error applying LED mapping:', error);
                }
            } else {
                console.log('ğŸ“‹ Using default LED layout');
                // å¦‚æœæ²¡æœ‰æ˜ å°„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤æ–¹å¼åˆ›å»ºLEDæŒ‰é’®ï¼ˆç½‘æ ¼å¸ƒå±€ï¼‰
                let ledIndex = 0;
                let maxLedIndex = 0;
                hidDevice.collections.forEach((collection) => {
                    if (!collection.outputReports || collection.outputReports.length === 0) {
                        return;
                    }

                    collection.outputReports.forEach((report) => {
                        report.items.forEach((item) => {
                            const reportCount = item.reportCount || 1;
                            
                            for (let i = 0; i < reportCount; i++) {
                                const ledName = `${ledIndex}`;
                                // åˆ›å»ºç½‘æ ¼å¸ƒå±€ï¼šæ¯è¡Œ8ä¸ªï¼Œé—´è·12%
                                const col = ledIndex % 8;
                                const row = Math.floor(ledIndex / 8);
                                const x = 6 + col * 12; // 6, 18, 30, 42, 54, 66, 78, 90
                                const y = 6 + row * 12;
                                const button = createLEDButton(ledIndex, ledName, 'white', null, null, 'circle', true, 80, x, y);
                                container.appendChild(button);
                                updateLEDVisual(ledIndex, 'white', null);
                                maxLedIndex = ledIndex;
                                ledIndex++;
                            }
                        });
                    });
                });
                
                // è®¡ç®—é»˜è®¤å¸ƒå±€çš„æœ€å°é«˜åº¦
                const calculateMinHeight = () => {
                    const totalRows = Math.floor(maxLedIndex / 8) + 1;
                    const basePercent = 10;
                    const actualSize = basePercent * 80 / 100; // size=80
                    const lastRowY = 6 + (totalRows - 1) * 12;
                    const maxBottom = lastRowY + actualSize;
                    const minHeight = (maxBottom + 6) * container.offsetWidth / 100;
                    container.style.minHeight = `${minHeight}px`;
                };
                
                setTimeout(calculateMinHeight, 0);
                window.addEventListener('resize', calculateMinHeight);
            }

            if (container.children.length === 0) {
                container.innerHTML = '<div style="text-align:center;color:#6c757d;"><span class="lang-en">No output LEDs found</span><span class="lang-zh">æœªæ‰¾åˆ°è¾“å‡º LED</span></div>';
            }
        }

        function createLEDButton(index, name, color = 'white', channel = null, groupId = null, shape = 'square', showIcon = true, size = 100, x = 0, y = 0) {
            const button = document.createElement('div');
            
            // å¦‚æœæ˜¯RGBç±»å‹ä¸”indexä¸æ˜¯æ•°ç»„ï¼Œè‡ªåŠ¨è½¬æ¢ä¸ºæ•°ç»„[index, index+1, index+2]
            if (color === 'rgb' && !Array.isArray(index)) {
                index = [index, index + 1, index + 2];
            }
            
            const isRGB = (color === 'rgb' && Array.isArray(index));
            button.className = `led-button shape-${shape || 'square'}${isRGB ? ' rgb-type' : ''}`;
            
            // RGBç±»å‹ä½¿ç”¨groupIdä½œIDï¼Œå…¶ä»–ä½¿ç”¨index
            const buttonId = isRGB ? `led-rgb-${groupId}` : `led-${index}${channel || ''}`;
            button.id = buttonId;
            button.style.position = 'absolute';
            
            // ä¿å­˜indexï¼ˆå¯èƒ½æ˜¯æ•°ç»„æˆ–å•ä¸ªæ•°å­—ï¼‰
            if (Array.isArray(index)) {
                button.dataset.ledIndices = JSON.stringify(index);
            } else {
                button.dataset.ledIndex = index;
            }
            button.dataset.ledColor = color;
            if (channel) button.dataset.channel = channel;
            if (groupId) button.dataset.groupId = groupId;
            if (shape) button.dataset.shape = shape;
            
            // åº”ç”¨sizeç¼©æ”¾ï¼ˆåŸºäºå®¹å™¨å®½åº¦ï¼‰
            // åŸºç¡€å¤§å°ä¸ºå®¹å™¨å®½åº¦çš„10%ï¼Œsizeä¸ºç¼©æ”¾å› å­ï¼ˆ100=åŸå§‹å¤§å°ï¼‰
            const basePercent = 10; // åŸºç¡€å¤§å°å å®¹å™¨å®½åº¦çš„ç™¾åˆ†æ¯”
            const actualSize = basePercent * (size || 100) / 100;
            
            // æ ¹æ®å½¢çŠ¶è®¾ç½®å®½é«˜æ¯”
            let widthSize = actualSize;
            let heightSize = actualSize;
            
            if (shape === 'portrait') {
                // ç«–é•¿æ–¹å½¢ï¼šå®½5 é«˜8
                widthSize = actualSize * 5 / 8;
                heightSize = actualSize;
            } else if (shape === 'landscape') {
                // æ¨ªé•¿æ–¹å½¢ï¼šå®½8 é«˜5
                widthSize = actualSize;
                heightSize = actualSize * 5 / 8;
            }
            // square å’Œ circle ä¿æŒ 1:1
            
            // åº”ç”¨Xã€Yåæ ‡å®šä½ï¼ˆXå’ŒYéƒ½æ˜¯0-100çš„æ•°å€¼ï¼Œéƒ½ç›¸å¯¹äºå®¹å™¨å®½åº¦è®¡ç®—ï¼Œä¿æŒ1:1æ¯”ä¾‹ï¼‰
            // åæ ‡ä»£è¡¨å…ƒç´ çš„ä¸­å¿ƒç‚¹
            if (x !== undefined && x !== null) {
                button.style.left = `calc(var(--container-width) * ${x} / 100 - var(--container-width) * ${widthSize} / 200)`;
            }
            if (y !== undefined && y !== null) {
                // Yä½¿ç”¨å®¹å™¨å®½åº¦ä½œä¸ºåŸºå‡†ï¼Œå°†æ•°å€¼è½¬æ¢ä¸ºåƒç´ 
                button.style.top = `calc(var(--container-width) * ${y} / 100 - var(--container-width) * ${heightSize} / 200)`;
            }
            
            button.style.width = `calc(var(--container-width) * ${widthSize} / 100)`;
            button.style.height = `calc(var(--container-width) * ${heightSize} / 100)`;
            button.style.fontSize = `calc(var(--container-width) * ${actualSize} / 100 * 0.15)`; // å­—ä½“å¤§å°ä¹ŸæŒ‰æ¯”ä¾‹è°ƒæ•´
            
            const iconHtml = showIcon ? '<div class="led-icon">ğŸ’¡</div>' : '';
            const rgbSlidersHtml = (color === 'rgb' && Array.isArray(index)) ? `
                <div class="rgb-sliders">
                    <div class="rgb-sliders-row">
                        <div class="rgb-slider-container">
                            <div class="rgb-slider-title">R</div>
                            <div class="rgb-slider r" data-channel="0">
                                <div class="rgb-slider-fill" data-channel="0"></div>
                                <div class="rgb-slider-value" id="rgb-val-${groupId}-0">0</div>
                            </div>
                        </div>
                        <div class="rgb-slider-container">
                            <div class="rgb-slider-title">G</div>
                            <div class="rgb-slider g" data-channel="1">
                                <div class="rgb-slider-fill" data-channel="1"></div>
                                <div class="rgb-slider-value" id="rgb-val-${groupId}-1">0</div>
                            </div>
                        </div>
                        <div class="rgb-slider-container">
                            <div class="rgb-slider-title">B</div>
                            <div class="rgb-slider b" data-channel="2">
                                <div class="rgb-slider-fill" data-channel="2"></div>
                                <div class="rgb-slider-value" id="rgb-val-${groupId}-2">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            ` : '';
            const indicatorId = (color === 'rgb' && Array.isArray(index)) ? `brightness-rgb-${groupId}` : `brightness-${index}${channel || ''}`;
            const indicatorHtml = (color === 'rgb' && Array.isArray(index)) ? '' : `<div class="brightness-indicator" id="${indicatorId}">0</div>`;
            button.innerHTML = `
                <div class="led-name">${name}</div>
                ${iconHtml}
                ${rgbSlidersHtml}
                ${indicatorHtml}
            `;
            
            // ç‚¹å‡»äº‹ä»¶ï¼šéRGBç±»å‹åˆ‡æ¢äº®ç­
            button.addEventListener('click', (e) => {
                if (!button.classList.contains('dragging') && color !== 'rgb') {
                    toggleLED(index, color, channel);
                }
            });
            
            // RGBç±»å‹ï¼šè®¾ç½®æ»‘æ¡äº¤äº’
            if (color === 'rgb' && Array.isArray(index)) {
                const sliderContainers = button.querySelectorAll('.rgb-slider-container');
                sliderContainers.forEach((container) => {
                    const slider = container.querySelector('.rgb-slider');
                    const channelIndex = parseInt(slider.dataset.channel);
                    const fill = slider.querySelector('.rgb-slider-fill');
                    const valueLabel = container.querySelector('.rgb-slider-value');
                    
                    let isDragging = false;
                    
                    const updateSlider = (e) => {
                        const rect = slider.getBoundingClientRect();
                        const y = e.clientY - rect.top;
                        const height = rect.height;
                        const percent = Math.max(0, Math.min(1, 1 - (y / height)));
                        const value = Math.round(percent * 255);
                        
                        ledStates[index[channelIndex]] = value;
                        fill.style.height = `${percent * 100}%`;
                        
                        // æ›´æ–°æ•°å€¼æ˜¾ç¤º
                        if (valueLabel) {
                            valueLabel.textContent = value;
                        }
                        
                        updateLEDVisual(index, 'rgb', null);
                        sendOutputReport();
                    };
                    
                    slider.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        updateSlider(e);
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) {
                            updateSlider(e);
                            e.preventDefault();
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    // åˆå§‹åŒ–æ»‘æ¡é«˜åº¦å’Œæ•°å€¼æ˜¾ç¤º
                    const initialValue = ledStates[index[channelIndex]] || 0;
                    fill.style.height = `${(initialValue / 255) * 100}%`;
                    if (valueLabel) {
                        valueLabel.textContent = initialValue;
                    }
                });
            }

            // æ‹–æ‹½è°ƒæ•´ï¼ˆä»…é™éRGBç±»å‹ï¼‰
            if (color !== 'rgb') {
                let isDragging = false;
                let lastY = 0;

                button.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastY = e.clientY;
                    button.classList.add('dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaY = lastY - e.clientY;
                    const sensitivity = 2;
                    const currentBrightness = ledStates[index] || 0;
                    let newBrightness = currentBrightness + Math.round(deltaY * sensitivity);
                    newBrightness = Math.max(0, Math.min(255, newBrightness));
                    setLEDBrightness(index, newBrightness, color, channel);
                    lastY = e.clientY;
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        button.classList.remove('dragging');
                    }
                });
            }
            
            updateLEDVisual(index, color, channel);
            return button;
        }

        function setLEDBrightness(index, brightness, color = 'white', channel = null) {
            ledStates[index] = brightness;
            updateLEDVisual(index, color, channel);
            sendOutputReport();
        }

        // è®¾ç½®RGBç¯çš„é¢œè‰²
        function setRGBColor(groupId, r, g, b) {
            // æŸ¥æ‰¾è¯¥groupIdå¯¹åº”çš„ä¸‰ä¸ªé€šé“ç´¢å¼•
            const light = currentLedMapping.lights.find(led => led.name === groupId && led.color === 'rgb');
            if (light && Array.isArray(light.index)) {
                ledStates[light.index[0]] = r; // Ré€šé“
                ledStates[light.index[1]] = g; // Gé€šé“
                ledStates[light.index[2]] = b; // Bé€šé“
                
                // æ›´æ–°è§†è§‰ï¼ˆä½¿ç”¨RGBæŒ‰é’®IDï¼‰
                updateLEDVisual(light.index, 'rgb', null);
                
                sendOutputReport();
            }
        }

        // è°ƒæ•´RGBç¯çš„äº®åº¦ï¼ˆä¿æŒé¢œè‰²æ¯”ä¾‹ï¼‰
        function adjustRGBBrightness(groupId, delta) {
            const light = currentLedMapping.lights.find(led => led.name === groupId && led.color === 'rgb');
            if (!light || !Array.isArray(light.index)) return;
            
            const rIndex = light.index[0];
            const gIndex = light.index[1];
            const bIndex = light.index[2];
            
            let r = ledStates[rIndex] || 0;
            let g = ledStates[gIndex] || 0;
            let b = ledStates[bIndex] || 0;
            
            // è®¡ç®—å½“å‰æœ€å¤§å€¼ï¼ˆç”¨äºä¿æŒé¢œè‰²æ¯”ä¾‹ï¼‰
            const maxValue = Math.max(r, g, b, 1);
            
            // è®¡ç®—æ–°çš„æœ€å¤§å€¼
            let newMaxValue = maxValue + Math.round(delta);
            newMaxValue = Math.max(0, Math.min(255, newMaxValue));
            
            // æŒ‰æ¯”ä¾‹è°ƒæ•´æ‰€æœ‰é€šé“
            const ratio = newMaxValue / maxValue;
            r = Math.round(r * ratio);
            g = Math.round(g * ratio);
            b = Math.round(b * ratio);
            
            // æ›´æ–°çŠ¶æ€
            ledStates[rIndex] = r;
            ledStates[gIndex] = g;
            ledStates[bIndex] = b;
            
            // æ›´æ–°è§†è§‰
            updateLEDVisual(light.index, 'rgb', null);
            
            sendOutputReport();
        }

        // è°ƒæ•´RGBç¯çš„é¥±å’Œåº¦ï¼ˆç°åº¦ï¼‰
        function adjustRGBSaturation(groupId, deltaX) {
            const light = currentLedMapping.lights.find(led => led.name === groupId && led.color === 'rgb');
            if (!light || !Array.isArray(light.index)) return;
            
            const rIndex = light.index[0];
            const gIndex = light.index[1];
            const bIndex = light.index[2];
            
            let r = ledStates[rIndex] || 0;
            let g = ledStates[gIndex] || 0;
            let b = ledStates[bIndex] || 0;
            
            // è®¡ç®—å½“å‰çš„å¹³å‡å€¼ï¼ˆç°åº¦ï¼‰
            const avg = (r + g + b) / 3;
            
            // è°ƒæ•´é¥±å’Œåº¦ï¼šå‘å³æ‹–æ‹½å¢åŠ é¥±å’Œåº¦ï¼ˆç¦»ç°åº¦æ›´è¿œï¼‰ï¼Œå‘å·¦æ‹–æ‹½é™ä½é¥±å’Œåº¦ï¼ˆè¶‹å‘ç°åº¦ï¼‰
            const sensitivity = 0.02; // é¥±å’Œåº¦è°ƒæ•´çµæ•åº¦
            const saturationChange = deltaX * sensitivity;
            
            // è®¡ç®—æ–°çš„RGBå€¼ï¼šåœ¨å½“å‰å€¼å’Œç°åº¦ä¹‹é—´æ’å€¼
            // saturationChange > 0: å¢åŠ é¥±å’Œåº¦ï¼ˆè¿œç¦»ç°åº¦ï¼‰
            // saturationChange < 0: é™ä½é¥±å’Œåº¦ï¼ˆè¶‹å‘ç°åº¦ï¼‰
            r = r + (r - avg) * saturationChange;
            g = g + (g - avg) * saturationChange;
            b = b + (b - avg) * saturationChange;
            
            // é™åˆ¶èŒƒå›´
            r = Math.max(0, Math.min(255, Math.round(r)));
            g = Math.max(0, Math.min(255, Math.round(g)));
            b = Math.max(0, Math.min(255, Math.round(b)));
            
            // æ›´æ–°çŠ¶æ€
            ledStates[rIndex] = r;
            ledStates[gIndex] = g;
            ledStates[bIndex] = b;
            
            // æ›´æ–°è§†è§‰ï¼ˆä½¿ç”¨RGBæŒ‰é’®IDï¼‰
            const rgbLight = currentLedMapping.lights.find(led => led.name === groupId && led.color === 'rgb');
            if (rgbLight) {
                updateLEDVisual(rgbLight.index, 'rgb', null);
            }
            
            sendOutputReport();
        }

        function updateLEDVisual(index, color = 'white', channel = null) {
            // RGBç±»å‹ä½¿ç”¨æ•°ç»„ç´¢å¼•ï¼Œå…¶ä»–ä½¿ç”¨å•ä¸ªç´¢å¼•
            let button;
            if (color === 'rgb' && Array.isArray(index)) {
                // é€šè¿‡indexæ•°ç»„æŸ¥æ‰¾å¯¹åº”çš„RGBæŒ‰é’®
                const buttons = document.querySelectorAll('.led-button.rgb-type');
                for (const btn of buttons) {
                    const indices = btn.dataset.ledIndices;
                    if (indices && JSON.stringify(JSON.parse(indices)) === JSON.stringify(index)) {
                        button = btn;
                        break;
                    }
                }
            } else {
                const buttonId = `led-${index}${channel || ''}`;
                button = document.getElementById(buttonId);
            }
            
            if (!button) return;
            
            // RGBç±»å‹æ˜¾ç¤ºæ··åˆåçš„äº®åº¦
            let brightness;
            if (color === 'rgb' && Array.isArray(index)) {
                const r = ledStates[index[0]] || 0;
                const g = ledStates[index[1]] || 0;
                const b = ledStates[index[2]] || 0;
                brightness = Math.max(r, g, b); // ä½¿ç”¨æœ€å¤§å€¼ä½œä¸ºæ˜¾ç¤ºäº®åº¦
                
                // æ›´æ–°äº®åº¦æŒ‡ç¤ºå™¨
                const indicator = button.querySelector('.brightness-indicator');
                if (indicator) {
                    indicator.textContent = brightness;
                }
            } else {
                brightness = ledStates[index] || 0;
                
                // æ›´æ–°äº®åº¦æ˜¾ç¤º
                const indicator = document.getElementById(`brightness-${index}${channel || ''}`);
                if (indicator) {
                    indicator.textContent = brightness;
                }
            }
            
            // å®šä¹‰é¢œè‰²æ˜ å°„ï¼ˆåœ¨ä¸¤ç§çŠ¶æ€éƒ½éœ€è¦ä½¿ç”¨ï¼‰
            const colorMap = {
                'red': { hue: 0, rgb: '255, 0, 0' },
                'green': { hue: 120, rgb: '0, 255, 0' },
                'blue': { hue: 240, rgb: '0, 0, 255' },
                'yellow': { hue: 60, rgb: '255, 255, 0' },
                'cyan': { hue: 180, rgb: '0, 255, 255' },
                'magenta': { hue: 300, rgb: '255, 0, 255' },
                'white': { hue: 0, rgb: '255, 255, 255' },
                'orange': { hue: 30, rgb: '255, 165, 0' }
            };
            
            // è®¡ç®—æš—è‰²å¤–æ¡†å’Œä¸»ä½“é¢œè‰²
            let darkBorderColor, hue, saturation;
            
            if (color === 'rgb' && Array.isArray(index)) {
                // RGBç±»å‹ï¼šæ ¹æ®å®é™…RGBå€¼è®¡ç®—è‰²ç›¸
                const r = ledStates[index[0]] || 0;
                const g = ledStates[index[1]] || 0;
                const b = ledStates[index[2]] || 0;
                
                // è®¡ç®—è‰²ç›¸ï¼ˆç®€åŒ–ç‰ˆï¼‰
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                if (delta === 0 || max === 0) {
                    hue = 0; // ç°è‰²
                    saturation = 0; // æ— é¥±å’Œåº¦ï¼Œæ˜¾ç¤ºä¸ºç°è‰²
                } else {
                    saturation = 20; // æ­£å¸¸é¥±å’Œåº¦
                    if (max === r) {
                        hue = 60 * (((g - b) / delta) % 6);
                    } else if (max === g) {
                        hue = 60 * (((b - r) / delta) + 2);
                    } else {
                        hue = 60 * (((r - g) / delta) + 4);
                    }
                    if (hue < 0) hue += 360;
                }
                
                darkBorderColor = max === 0 ? `hsl(0, 0%, 25%)` : `hsl(${hue}, 100%, 25%)`;
            } else {
                const colorInfo = colorMap[color] || colorMap['white'];
                hue = colorInfo.hue;
                saturation = 20;
                if (color === 'white') {
                    darkBorderColor = `hsl(0, 0%, 35%)`;
                } else {
                    darkBorderColor = `hsl(${hue}, 100%, 22%)`;
                }
            }
            
            // ä¸»ä½“å›ºå®šä¸º85%äº®åº¦ã€æ ¹æ®é¢œè‰²è°ƒæ•´é¥±å’Œåº¦
            button.style.background = `linear-gradient(145deg, hsl(${hue}, ${saturation}%, 85%), hsl(${hue}, ${saturation}%, 80%))`;
            
            if (brightness === 0) {
                // å…³é—­çŠ¶æ€ - åªæ˜¾ç¤ºä¸»ä½“ï¼Œæ— å…‰æ™•
                button.classList.remove('on');
                button.style.borderColor = darkBorderColor;
                button.style.boxShadow = '';
                button.style.color = '#444';
            } else {
                // äº®èµ·çŠ¶æ€ï¼šä¸»ä½“ä¸å˜ï¼Œåªé€šè¿‡å…‰æ™•æ˜¾ç¤ºç‚¹äº®æ•ˆæœ
                button.classList.add('on');
                
                // ä½¿ç”¨ RGB æ¨¡å¼è®¡ç®—å…‰æ™•ï¼š
                // 0-160: æ˜ å°„åˆ°é¢œè‰²çš„ 0-255
                // 160-255: ä¿æŒä¸»é¢œè‰² 255ï¼Œé€æ­¥æé«˜å…¶ä»–é€šé“åˆ° 128ï¼ˆå‘ç™½ä½†ä¸å®Œå…¨ç™½ï¼‰
                let glowR, glowG, glowB;
                const glowAlpha = 0.2 + (brightness / 255) * 0.6;
                
                // è·å–åŸºç¡€é¢œè‰²çš„ RGB
                let baseR, baseG, baseB;
                if (color === 'rgb' && Array.isArray(index)) {
                    // RGBç±»å‹ï¼šä½¿ç”¨å®é™…çš„RGBå€¼
                    baseR = (ledStates[index[0]] || 0) / 255;
                    baseG = (ledStates[index[1]] || 0) / 255;
                    baseB = (ledStates[index[2]] || 0) / 255;
                    
                    // å¯¹äºRGBç±»å‹ï¼Œbrightnesså·²ç»æ˜¯æœ€å¤§å€¼
                } else {
                    const colorInfo = colorMap[color] || colorMap['white'];
                    const rgb = colorInfo.rgb.split(',').map(v => parseInt(v.trim()));
                    baseR = rgb[0] / 255;
                    baseG = rgb[1] / 255;
                    baseB = rgb[2] / 255;
                }
                
                if (brightness <= 160) {
                    // 0-160: çº¿æ€§æ˜ å°„åˆ°é¢œè‰²çš„ 0-255
                    const intensity = (brightness / 160) * 255;
                    glowR = Math.round(baseR * intensity);
                    glowG = Math.round(baseG * intensity);
                    glowB = Math.round(baseB * intensity);
                } else {
                    // 160-255: ä¸»é¢œè‰²ä¿æŒ 255ï¼Œå…¶ä»–é€šé“æå‡åˆ° 128
                    const ratio = (brightness - 160) / 95;
                    const otherChannelValue = Math.round(ratio * 128);
                    glowR = baseR === 1 ? 255 : Math.round(baseR * 255 + (1 - baseR) * otherChannelValue);
                    glowG = baseG === 1 ? 255 : Math.round(baseG * 255 + (1 - baseG) * otherChannelValue);
                    glowB = baseB === 1 ? 255 : Math.round(baseB * 255 + (1 - baseB) * otherChannelValue);
                }
                
                const glowColor = `rgba(${glowR}, ${glowG}, ${glowB}, ${glowAlpha})`;
                
                let borderColor;
                if (color === 'rgb' && channel) {
                    switch (channel) {
                        case 'R':
                            borderColor = `hsl(0, 100%, 30%)`;
                            break;
                        case 'G':
                            borderColor = `hsl(120, 100%, 25%)`;
                            break;
                        case 'B':
                            borderColor = `hsl(240, 100%, 30%)`;
                            break;
                    }
                } else {
                    if (color === 'white') {
                        borderColor = `hsl(0, 0%, 40%)`;
                    } else {
                        borderColor = `hsl(${hue}, 100%, 25%)`;
                    }
                }
                
                button.style.borderColor = borderColor;
                
                // å¢å¼ºçš„å…‰æ™•æ•ˆæœï¼šå†…éƒ¨å…‰æ™•+å¤–éƒ¨æ‰©æ•£+åº•éƒ¨é˜´å½±
                // è“è‰²ç³»éœ€è¦é¢å¤–å¢å¼ºï¼ˆäººçœ¼å¯¹è“è‰²æ„ŸçŸ¥è¾ƒæš—ï¼‰
                const isBlue = (color === 'blue' || color === 'cyan' || (color === 'rgb' && channel === 'B'));
                const glowBoost = isBlue ? 1.4 : 1.0;
                const glowIntensity = (0.3 + (brightness / 255) * 0.7) * glowBoost;
                const glowSize = (15 + (brightness / 255) * 25) * glowBoost;
                button.style.boxShadow = `
                    0 0 ${glowSize * 0.4}px ${glowColor},
                    0 0 ${glowSize}px ${glowColor.replace(/[\d.]+\)$/, `${glowIntensity * 0.5})`)},
                    0 0 ${glowSize * 1.5}px ${glowColor.replace(/[\d.]+\)$/, `${glowIntensity * 0.3})`)},
                    0 4px 12px rgba(0,0,0,0.3)`;
                
                // æ–‡å­—é¢œè‰²
                button.style.color = '#444';
            }
        }

        async function toggleLED(index, color = 'white', channel = null) {
            if (!hidDevice) {
                const isZh = document.body.classList.contains('zh');
                alert(isZh ? 'æœªè¿æ¥è®¾å¤‡' : 'No HID device connected');
                return;
            }

            // åˆ‡æ¢çŠ¶æ€ï¼š0 -> 255, å…¶ä»– -> 0
            ledStates[index] = ledStates[index] === 0 ? 255 : 0;
            
            // æ›´æ–°è§†è§‰æ•ˆæœ
            updateLEDVisual(index, color, channel);

            // å‘é€æŠ¥å‘Š
            await sendOutputReport();
        }

        async function sendOutputReport() {
            try {
                // æ„å»ºè¾“å‡ºæ•°æ®
                const data = new Uint8Array(outputReportSize);
                
                // å¡«å……æ¯ä¸ª LED çš„çŠ¶æ€
                Object.keys(ledStates).forEach(index => {
                    const byteIndex = parseInt(index);
                    if (byteIndex < data.length) {
                        data[byteIndex] = ledStates[index];
                    }
                });

                // å‘é€æŠ¥å‘Š
                await hidDevice.sendReport(outputReportId, data);

            } catch (error) {
                console.error('Failed to send output report:', error);
                const isZh = document.body.classList.contains('zh');
                alert(isZh ? `å‘é€å¤±è´¥: ${error.message}` : `Failed to send LED data: ${error.message}`);
            }
        }

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        window.addEventListener('gamepadconnected', (e) => {
            console.log('æ‰‹æŸ„å·²è¿æ¥:', e.gamepad);
            updateStatus();
            renderGamepads(); // æ·»åŠ è¿™è¡Œ
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('æ‰‹æŸ„å·²æ–­å¼€:', e.gamepad);
            delete gamepads[e.gamepad.index];
            delete buttonStates[e.gamepad.index];
            delete buttonCounts[e.gamepad.index];
            delete stickTrails[e.gamepad.index];
            updateStatus();
            renderGamepads();
        });

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus() {
            const gamepadList = navigator.getGamepads();
            const connectedGamepads = Array.from(gamepadList).filter(gp => gp !== null);
            
            const statusElement = document.getElementById('status');
            if (connectedGamepads.length > 0) {
                statusElement.innerHTML = `<span class="lang-en">Connected ${connectedGamepads.length} gamepad(s)</span><span class="lang-zh">å·²è¿æ¥ ${connectedGamepads.length} ä¸ªæ‰‹æŸ„</span>`;
                statusElement.className = 'status connected';
            } else {
                statusElement.innerHTML = '<span class="lang-en">Please connect a gamepad and press any button to activate</span><span class="lang-zh">è¯·è¿æ¥æ¸¸æˆæ‰‹æŸ„å¹¶æŒ‰ä»»æ„æŒ‰é’®æ¿€æ´»</span>';
                statusElement.className = 'status disconnected';
            }
        }

        // è·å–æŒ‰é’®ä¿¡æ¯ï¼ˆåç§°å’Œç±»å‹ï¼‰
        function getButtonInfo(index) {
            return { name: `${index}`, type: 'default' };
        }

        // è·å–è½´åç§°
        function getAxisName(index) {
            const axisNames = [
                '<span class="lang-en">Left X</span><span class="lang-zh">å·¦ X</span>', 
                '<span class="lang-en">Left Y</span><span class="lang-zh">å·¦ Y</span>', 
                '<span class="lang-en">Right X</span><span class="lang-zh">å³ X</span>', 
                '<span class="lang-en">Right Y</span><span class="lang-zh">å³ Y</span>'
            ];
            return axisNames[index] || `<span class="lang-en">Axis ${index}</span><span class="lang-zh">è½´ ${index}</span>`;
        }

        // æ›´æ–°æ‘‡æ†æ‹–å°¾æ•ˆæœ
        function updateStickTrail(gamepadIndex, stickName, posX, posY, canvasElement) {
            const key = `${gamepadIndex}-${stickName}`;
            const maxTrails = 15; // æœ€å¤§æ‹–å°¾ç‚¹æ•°é‡
            
            // åˆå§‹åŒ–æ‹–å°¾æ•°ç»„
            if (!stickTrails[key]) {
                stickTrails[key] = [];
            }
            
            // æ·»åŠ æ–°ä½ç½®
            stickTrails[key].push({ x: posX, y: posY, time: Date.now() });
            
            // é™åˆ¶æ‹–å°¾æ•°é‡
            if (stickTrails[key].length > maxTrails) {
                stickTrails[key].shift();
            }
            
            // æ¸…é™¤æ—§çš„æ‹–å°¾å…ƒç´ 
            if (canvasElement) {
                const oldTrails = canvasElement.querySelectorAll('.stick-2d-trail');
                oldTrails.forEach(trail => trail.remove());
                
                // åˆ›å»ºæ–°çš„æ‹–å°¾å…ƒç´ 
                stickTrails[key].forEach((pos, index) => {
                    const trail = document.createElement('div');
                    trail.className = 'stick-2d-trail';
                    trail.style.left = `${pos.x}%`;
                    trail.style.top = `${pos.y}%`;
                    
                    // è®¡ç®—é€æ˜åº¦ï¼ˆè¶Šæ—§è¶Šé€æ˜ï¼‰
                    const opacity = (index + 1) / stickTrails[key].length * 0.5;
                    trail.style.opacity = opacity;
                    
                    // è®¡ç®—å¤§å°ï¼ˆè¶Šæ—§è¶Šå°ï¼‰
                    const size = 4 + (index + 1) / stickTrails[key].length * 6;
                    trail.style.width = `${size}px`;
                    trail.style.height = `${size}px`;
                    
                    canvasElement.appendChild(trail);
                });
            }
        }

        // æ›´æ–°å•è½´æ‹–å°¾æ•ˆæœ
        function updateAxisTrail(gamepadIndex, axisIndex, position, containerElement) {
            const key = `axis-${gamepadIndex}-${axisIndex}`;
            const maxTrails = 15; // æœ€å¤§æ‹–å°¾ç‚¹æ•°é‡
            
            // åˆå§‹åŒ–æ‹–å°¾æ•°ç»„
            if (!stickTrails[key]) {
                stickTrails[key] = [];
            }
            
            // æ·»åŠ æ–°ä½ç½®
            stickTrails[key].push({ position: position, time: Date.now() });
            
            // é™åˆ¶æ‹–å°¾æ•°é‡
            if (stickTrails[key].length > maxTrails) {
                stickTrails[key].shift();
            }
            
            // æ¸…é™¤æ—§çš„æ‹–å°¾å…ƒç´ 
            if (containerElement) {
                const oldTrails = containerElement.querySelectorAll('.axis-trail');
                oldTrails.forEach(trail => trail.remove());
                
                // åˆ›å»ºæ–°çš„æ‹–å°¾å…ƒç´ 
                stickTrails[key].forEach((pos, index) => {
                    const trail = document.createElement('div');
                    trail.className = 'axis-trail';
                    trail.style.top = `${pos.position}%`;
                    
                    // è®¡ç®—é€æ˜åº¦ï¼ˆè¶Šæ—§è¶Šé€æ˜ï¼‰
                    const opacity = (index + 1) / stickTrails[key].length * 0.4;
                    trail.style.opacity = opacity;
                    
                    // è®¡ç®—é«˜åº¦ï¼ˆè¶Šæ—§è¶Šå°ï¼‰
                    const height = 2 + (index + 1) / stickTrails[key].length * 2;
                    trail.style.height = `${height}px`;
                    
                    containerElement.appendChild(trail);
                });
            }
        }

        // æ£€æµ‹æŒ‰é’®çŠ¶æ€å˜åŒ–
        function checkButtonPress(gamepadIndex, buttonIndex, isPressed) {
            const key = `${gamepadIndex}-${buttonIndex}`;
            
            // åˆå§‹åŒ–çŠ¶æ€
            if (!(key in buttonStates)) {
                buttonStates[key] = false;
                buttonCounts[key] = 0;
            }

            // æ£€æµ‹æŒ‰ä¸‹è¾¹æ²¿ï¼ˆä»æœªæŒ‰ä¸‹å˜ä¸ºæŒ‰ä¸‹ï¼‰
            if (isPressed && !buttonStates[key]) {
                buttonStates[key] = true;
                buttonCounts[key]++;
            } else if (!isPressed && buttonStates[key]) {
                buttonStates[key] = false;
            }

            // å®æ—¶æ›´æ–°è§†è§‰çŠ¶æ€ï¼ˆæŒ‰ä¸‹äº®èµ·ï¼Œæ¾å¼€ç†„ç­ï¼‰
            const buttonElement = document.getElementById(`button-${gamepadIndex}-${buttonIndex}`);
            if (buttonElement) {
                if (isPressed) {
                    buttonElement.classList.add('pressed');
                } else {
                    buttonElement.classList.remove('pressed');
                }
            }
        }



        // æ¸²æŸ“æ‰‹æŸ„ç•Œé¢
        function renderGamepads() {
            const container = document.getElementById('gamepads');
            container.innerHTML = '';

            const gamepadList = navigator.getGamepads();
            
            for (let i = 0; i < gamepadList.length; i++) {
                const gamepad = gamepadList[i];
                if (!gamepad) continue;

                const gamepadDiv = document.createElement('div');
                gamepadDiv.className = 'gamepad';

                // æŒ‰æŒ‰é’®ç±»å‹åˆ†ç»„
                const buttonGroups = {
                    default: { title: '<span class="lang-en">Buttons</span><span class="lang-zh">æŒ‰é’®</span>', buttons: [] }
                };

                gamepad.buttons.forEach((button, buttonIndex) => {
                    const buttonInfo = getButtonInfo(buttonIndex);
                    const key = `${gamepad.index}-${buttonIndex}`;
                    
                    // ç¡®ä¿åˆå§‹åŒ–è®¡æ•°
                    if (!(key in buttonCounts)) {
                        buttonCounts[key] = 0;
                    }
                    
                    const count = buttonCounts[key];
                    
                    buttonGroups.default.buttons.push({
                        index: buttonIndex,
                        name: buttonInfo.name,
                        type: buttonInfo.type,
                        count: count
                    });
                });

                let buttonsHTML = '';
                for (const [groupType, group] of Object.entries(buttonGroups)) {
                    if (group.buttons.length > 0) {
                        buttonsHTML += `
                            <div class="button-group">
                                <div class="button-group-title">${group.title}</div>
                                <div class="buttons-container">
                                    ${group.buttons.map(btn => `
                                        <div class="button-circle ${btn.type}" id="button-${gamepad.index}-${btn.index}">
                                            <div class="button-name">${btn.name}</div>
                                            <div class="button-count">${btn.count}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }

                gamepadDiv.innerHTML = `
                    <div class="gamepad-title">
                        ğŸ® ${gamepad.id} <span class="lang-en">Index</span><span class="lang-zh">ç´¢å¼•</span>: ${gamepad.index}
                        <button class="reset-btn" onclick="resetGamepad(${gamepad.index})" 
                                style="float: right; padding: 6px 12px; font-size: 14px; background-color: #6c757d;">
                            ğŸ”„ <span class="lang-en">Reset Counts</span><span class="lang-zh">å¤ä½è®¡æ•°</span>
                        </button>
                        <div style="clear: both;"></div>
                    </div>
                    ${buttonsHTML}
                    <div class="axes-section">
                        <h4><span class="lang-en">Axes</span><span class="lang-zh">æ‘‡æ†è½´</span></h4>
                        <div class="axes-grid">
                            ${gamepad.axes.length >= 2 ? `
                                <div class="stick-2d">
                                    <div class="axis-name"><span class="lang-en">Left Stick</span><span class="lang-zh">å·¦æ‘‡æ†</span></div>
                                    <div class="stick-2d-canvas" id="stick-left-${gamepad.index}">
                                        <div class="stick-2d-cross-h"></div>
                                        <div class="stick-2d-cross-v"></div>
                                        <div class="stick-2d-center"></div>
                                        <div class="stick-2d-indicator" id="stick-left-indicator-${gamepad.index}"></div>
                                    </div>
                                    <div class="stick-2d-value" id="stick-left-value-${gamepad.index}">X: 0.000, Y: 0.000</div>
                                </div>
                            ` : ''}
                            ${gamepad.axes.length >= 4 ? `
                                <div class="stick-2d">
                                    <div class="axis-name"><span class="lang-en">Right Stick</span><span class="lang-zh">å³æ‘‡æ†</span></div>
                                    <div class="stick-2d-canvas" id="stick-right-${gamepad.index}">
                                        <div class="stick-2d-cross-h"></div>
                                        <div class="stick-2d-cross-v"></div>
                                        <div class="stick-2d-center"></div>
                                        <div class="stick-2d-indicator" id="stick-right-indicator-${gamepad.index}"></div>
                                    </div>
                                    <div class="stick-2d-value" id="stick-right-value-${gamepad.index}">X: 0.000, Y: 0.000</div>
                                </div>
                            ` : ''}
                            ${gamepad.axes.map((axis, axisIndex) => `
                                <div class="axis-item">
                                    <div class="axis-name">${getAxisName(axisIndex)}</div>
                                    <div class="axis-bar">
                                        <div class="axis-center-line"></div>
                                        <div class="axis-indicator" id="axis-bar-${gamepad.index}-${axisIndex}"></div>
                                    </div>
                                    <div class="axis-value" id="axis-${gamepad.index}-${axisIndex}">${axis.toFixed(3)}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                container.appendChild(gamepadDiv);
            }
        }

        // ä¸»å¾ªç¯ - æŒç»­æ£€æµ‹æ‰‹æŸ„çŠ¶æ€
        function gameLoop() {
            const gamepadList = navigator.getGamepads();
            let needsRender = false;
            
            for (let i = 0; i < gamepadList.length; i++) {
                const gamepad = gamepadList[i];
                if (!gamepad) continue;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ‰‹æŸ„
                if (!gamepads[gamepad.index]) {
                    gamepads[gamepad.index] = true;
                    needsRender = true;
                }

                // æ£€æµ‹æŒ‰é’®çŠ¶æ€
                gamepad.buttons.forEach((button, buttonIndex) => {
                    const isPressed = button.pressed || button.value > 0.5;
                    checkButtonPress(gamepad.index, buttonIndex, isPressed);
                });

                // æ›´æ–°è½´æ˜¾ç¤º
                gamepad.axes.forEach((axis, axisIndex) => {
                    // é™åˆ¶è½´å€¼åˆ° -1 åˆ° +1 èŒƒå›´
                    const clampedAxis = Math.max(-1, Math.min(1, axis));
                    
                    const axisElement = document.getElementById(`axis-${gamepad.index}-${axisIndex}`);
                    if (axisElement) {
                        // æ˜¾ç¤ºåŸå§‹å€¼ï¼Œä½†æ ‡è®°å¦‚æœè¶…å‡ºèŒƒå›´
                        const displayValue = axis.toFixed(3);
                        const isOutOfRange = axis < -1 || axis > 1;
                        axisElement.textContent = isOutOfRange ? `${displayValue}âš ï¸` : displayValue;
                        
                        // å¦‚æœè¶…å‡ºèŒƒå›´ï¼Œæ”¹å˜é¢œè‰²
                        if (isOutOfRange) {
                            axisElement.style.color = 'red';
                            axisElement.style.fontWeight = 'bold';
                        } else {
                            axisElement.style.color = '';
                            axisElement.style.fontWeight = '';
                        }
                    }
                    
                    // æ›´æ–°è½´æ¡æ˜¾ç¤º - ä½¿ç”¨é™åˆ¶åçš„å€¼
                    const axisBarElement = document.getElementById(`axis-bar-${gamepad.index}-${axisIndex}`);
                    const axisBarContainer = axisBarElement ? axisBarElement.parentElement : null;
                    if (axisBarElement) {
                        const position = ((clampedAxis + 1) / 2) * 94; // ä½¿ç”¨é™åˆ¶åçš„å€¼
                        axisBarElement.style.top = `${position}%`;
                        
                        // å¦‚æœåŸå§‹å€¼è¶…å‡ºèŒƒå›´ï¼Œæ”¹å˜æŒ‡ç¤ºå™¨é¢œè‰²
                        if (axis < -1 || axis > 1) {
                            axisBarElement.style.background = '#dc3545'; // çº¢è‰²è­¦å‘Š
                        } else {
                            axisBarElement.style.background = '#007bff'; // é»˜è®¤è“è‰²
                        }
                        
                        // æ·»åŠ æ‹–å°¾æ•ˆæœ
                        updateAxisTrail(gamepad.index, axisIndex, position, axisBarContainer);
                    }
                });

                // æ›´æ–°2Dæ‘‡æ†æ˜¾ç¤º
                if (gamepad.axes.length >= 2) {
                    const leftX = Math.max(-1, Math.min(1, gamepad.axes[0]));
                    const leftY = Math.max(-1, Math.min(1, gamepad.axes[1]));
                    const leftIndicator = document.getElementById(`stick-left-indicator-${gamepad.index}`);
                    const leftValue = document.getElementById(`stick-left-value-${gamepad.index}`);
                    const leftCanvas = document.getElementById(`stick-left-${gamepad.index}`);
                    if (leftIndicator) {
                        const posX = ((leftX + 1) / 2) * 100;
                        const posY = ((leftY + 1) / 2) * 100;
                        leftIndicator.style.left = `${posX}%`;
                        leftIndicator.style.top = `${posY}%`;
                        
                        // æ·»åŠ æ‹–å°¾æ•ˆæœ
                        updateStickTrail(gamepad.index, 'left', posX, posY, leftCanvas);
                    }
                    if (leftValue) {
                        leftValue.textContent = `X: ${gamepad.axes[0].toFixed(3)}, Y: ${gamepad.axes[1].toFixed(3)}`;
                    }
                }
                
                if (gamepad.axes.length >= 4) {
                    const rightX = Math.max(-1, Math.min(1, gamepad.axes[2]));
                    const rightY = Math.max(-1, Math.min(1, gamepad.axes[3]));
                    const rightIndicator = document.getElementById(`stick-right-indicator-${gamepad.index}`);
                    const rightValue = document.getElementById(`stick-right-value-${gamepad.index}`);
                    const rightCanvas = document.getElementById(`stick-right-${gamepad.index}`);
                    if (rightIndicator) {
                        const posX = ((rightX + 1) / 2) * 100;
                        const posY = ((rightY + 1) / 2) * 100;
                        rightIndicator.style.left = `${posX}%`;
                        rightIndicator.style.top = `${posY}%`;
                        
                        // æ·»åŠ æ‹–å°¾æ•ˆæœ
                        updateStickTrail(gamepad.index, 'right', posX, posY, rightCanvas);
                    }
                    if (rightValue) {
                        rightValue.textContent = `X: ${gamepad.axes[2].toFixed(3)}, Y: ${gamepad.axes[3].toFixed(3)}`;
                    }
                }

                // æ›´æ–°æŒ‰é’®è®¡æ•°æ˜¾ç¤º
                gamepad.buttons.forEach((button, buttonIndex) => {
                    const key = `${gamepad.index}-${buttonIndex}`;
                    const count = buttonCounts[key] || 0;
                    const countElement = document.querySelector(`#button-${gamepad.index}-${buttonIndex} .button-count`);
                    if (countElement) {
                        countElement.textContent = count;
                    }
                });
            }

            if (needsRender) {
                renderGamepads();
            }

            updateStatus();
            requestAnimationFrame(gameLoop);
        }

        // å¤ä½æ‰€æœ‰è®¡æ•°
        function resetAllCounts() {
            buttonCounts = {};
            buttonStates = {};
            renderGamepads();
        }

        // å¤ä½å½“å‰æ‰‹æŸ„è®¡æ•°
        function resetCurrentGamepad() {
            const gamepadList = navigator.getGamepads();
            const connectedGamepads = Array.from(gamepadList).filter(gp => gp !== null);
            
            if (connectedGamepads.length === 0) {
                const isZh = document.body.classList.contains('zh');
                alert(isZh ? 'æ²¡æœ‰è¿æ¥çš„æ‰‹æŸ„' : 'No gamepad connected');
                return;
            }

            if (connectedGamepads.length === 1) {
                const gamepad = connectedGamepads[0];
                // å¤ä½è¿™ä¸ªæ‰‹æŸ„çš„æ‰€æœ‰æŒ‰é’®è®¡æ•°
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const key = `${gamepad.index}-${i}`;
                    buttonCounts[key] = 0;
                    buttonStates[key] = false;
                }
                renderGamepads();
            } else {
                // å¤šä¸ªæ‰‹æŸ„ï¼Œè®©ç”¨æˆ·é€‰æ‹©
                const isZh = document.body.classList.contains('zh');
                let gamepadIndex = prompt(isZh 
                    ? `æ£€æµ‹åˆ° ${connectedGamepads.length} ä¸ªæ‰‹æŸ„ï¼Œè¯·è¾“å…¥è¦å¤ä½çš„æ‰‹æŸ„ç´¢å¼• (0-${connectedGamepads.length-1}):` 
                    : `Detected ${connectedGamepads.length} gamepads, enter gamepad index to reset (0-${connectedGamepads.length-1}):`);
                gamepadIndex = parseInt(gamepadIndex);
                
                if (isNaN(gamepadIndex) || gamepadIndex < 0 || gamepadIndex >= gamepadList.length) {
                    const isZh = document.body.classList.contains('zh');
                    alert(isZh ? 'æ— æ•ˆçš„æ‰‹æŸ„ç´¢å¼•' : 'Invalid gamepad index');
                    return;
                }

                const gamepad = gamepadList[gamepadIndex];
                if (!gamepad) {
                    const isZh = document.body.classList.contains('zh');
                    alert(isZh ? 'è¯¥ç´¢å¼•çš„æ‰‹æŸ„æœªè¿æ¥' : 'Gamepad at this index is not connected');
                    return;
                }

                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const key = `${gamepadIndex}-${i}`;
                    buttonCounts[key] = 0;
                    buttonStates[key] = false;
                }
                renderGamepads();
            }
        }

        // å¤ä½æŒ‡å®šæ‰‹æŸ„
        function resetGamepad(gamepadIndex) {
            const gamepadList = navigator.getGamepads();
            const gamepad = gamepadList[gamepadIndex];
            
            if (!gamepad) {
                const isZh = document.body.classList.contains('zh');
                alert(isZh ? 'æ‰‹æŸ„æœªæ‰¾åˆ°' : 'Gamepad not found');
                return;
            }

            for (let i = 0; i < gamepad.buttons.length; i++) {
                const key = `${gamepadIndex}-${i}`;
                buttonCounts[key] = 0;
                buttonStates[key] = false;
            }
            renderGamepads();
        }

        // å¯åŠ¨ä¸»å¾ªç¯
        updateStatus();
        renderGamepads();
        gameLoop();
    </script>
</body>
</html>