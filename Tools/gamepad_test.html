<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gamepad Tester</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .status {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 5px;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        .reset-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
        }
        .reset-btn:hover {
            background-color: #c82333;
        }
        .gamepad {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .gamepad-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: flex-start;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .button-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e9ecef, #ffffff);
            border: 3px solid #dee2e6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .button-circle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .button-circle.pressed {
            background: linear-gradient(145deg, #28a745, #34ce57);
            border-color: #1e7e34;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
        }
        .button-name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 3px;
            text-align: center;
            line-height: 1;
        }
        .button-count {
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
        }
        .button-circle.pressed .button-count {
            color: white;
        }
        /* ç‰¹æ®ŠæŒ‰é’®é¢œè‰² */
        .button-circle.action {
            background: linear-gradient(145deg, #ffeaa7, #fdcb6e);
            border-color: #e17055;
        }
        .button-circle.shoulder {
            background: linear-gradient(145deg, #a29bfe, #6c5ce7);
            color: white;
        }
        .button-circle.dpad {
            background: linear-gradient(145deg, #fd79a8, #e84393);
            color: white;
        }
        .button-circle.system {
            background: linear-gradient(145deg, #636e72, #2d3436);
            color: white;
        }
        .axes-section {
            margin-top: 20px;
        }
        .axes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
            gap: 10px;
        }
        .axis-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }
        .axis-name {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .axis-value {
            font-size: 14px;
            font-family: monospace;
            margin-bottom: 8px;
        }
        .axis-bar {
            width: 100%;
            height: 80px;
            background: linear-gradient(to bottom, #e9ecef 0%, #f8f9fa 50%, #e9ecef 100%);
            border: 1px solid #ced4da;
            border-radius: 4px;
            position: relative;
            margin: 5px 0;
        }
        .axis-indicator {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #007bff;
            border-radius: 3px;
            transition: top 0.1s ease;
            box-shadow: 0 0 4px rgba(0, 123, 255, 0.5);
        }
        .axis-center-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #6c757d;
            transform: translateY(-50%);
        }
        .total-count {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .button-group {
            margin-bottom: 20px;
        }
        .button-group-title {
            font-size: 16px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Gamepad Button Tester æ¸¸æˆæ‰‹æŸ„æŒ‰é’®æ£€æµ‹å™¨</h1>
        <p style="text-align: center; color: #666;">For detecting button aging and bounce issues - Only counts button press edge triggers ç”¨äºæ£€æµ‹æŒ‰é’®è€åŒ–å’ŒæŠ–åŠ¨é—®é¢˜ - åªè®¡ç®—æŒ‰ä¸‹è¾¹æ²¿è§¦å‘æ¬¡æ•°</p>
        
        <div id="status" class="status disconnected">
            Please connect a gamepad and press any button to activate è¯·è¿æ¥æ¸¸æˆæ‰‹æŸ„å¹¶æŒ‰ä»»æ„æŒ‰é’®æ¿€æ´»
        </div>

        <div class="controls">
            <button class="reset-btn" onclick="resetAllCounts()">ğŸ”„ Reset All å¤ä½æ‰€æœ‰</button>
            <button class="reset-btn" onclick="resetCurrentGamepad()" style="background-color: #6c757d;">Reset Current å¤ä½å½“å‰</button>
        </div>

        <div class="total-count">
            Total Presses æ€»æŒ‰é”®æ¬¡æ•°: <span id="totalCount">0</span>
        </div>

        <div id="gamepads"></div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        let gamepads = {};
        let buttonStates = {};
        let buttonCounts = {};
        let totalCount = 0;
        let isGamepadSupported = 'getGamepads' in navigator;

        // åˆå§‹åŒ–
        if (!isGamepadSupported) {
            document.getElementById('status').textContent = 'Your browser does not support Gamepad API (æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Gamepad API)';
            document.getElementById('status').className = 'status disconnected';
        }

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        window.addEventListener('gamepadconnected', (e) => {
            console.log('æ‰‹æŸ„å·²è¿æ¥:', e.gamepad);
            updateStatus();
            renderGamepads(); // æ·»åŠ è¿™è¡Œ
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('æ‰‹æŸ„å·²æ–­å¼€:', e.gamepad);
            delete gamepads[e.gamepad.index];
            delete buttonStates[e.gamepad.index];
            delete buttonCounts[e.gamepad.index];
            updateStatus();
            renderGamepads();
        });

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus() {
            const gamepadList = navigator.getGamepads();
            const connectedGamepads = Array.from(gamepadList).filter(gp => gp !== null);
            
            const statusElement = document.getElementById('status');
            if (connectedGamepads.length > 0) {
                statusElement.textContent = `Connected ${connectedGamepads.length} gamepad(s) (å·²è¿æ¥ ${connectedGamepads.length} ä¸ªæ‰‹æŸ„)`;
                statusElement.className = 'status connected';
            } else {
                statusElement.textContent = 'Please connect a gamepad and press any button to activate (è¯·è¿æ¥æ¸¸æˆæ‰‹æŸ„å¹¶æŒ‰ä»»æ„æŒ‰é’®æ¿€æ´»)';
                statusElement.className = 'status disconnected';
            }
        }

        // è·å–æŒ‰é’®ä¿¡æ¯ï¼ˆåç§°å’Œç±»å‹ï¼‰
        function getButtonInfo(index) {
            return { name: `${index}`, type: 'default' };
        }

        // è·å–è½´åç§°
        function getAxisName(index) {
            const axisNames = [
                'Left X å·¦ X', 'Left Y å·¦ Y', 
                'Right X å³ X', 'Right Y å³ Y'
            ];
            return axisNames[index] || `Axis ${index} è½´ ${index}`;
        }

        // æ£€æµ‹æŒ‰é’®çŠ¶æ€å˜åŒ–
        function checkButtonPress(gamepadIndex, buttonIndex, isPressed) {
            const key = `${gamepadIndex}-${buttonIndex}`;
            
            // åˆå§‹åŒ–çŠ¶æ€
            if (!(key in buttonStates)) {
                buttonStates[key] = false;
                buttonCounts[key] = 0;
            }

            // æ£€æµ‹æŒ‰ä¸‹è¾¹æ²¿ï¼ˆä»æœªæŒ‰ä¸‹å˜ä¸ºæŒ‰ä¸‹ï¼‰
            if (isPressed && !buttonStates[key]) {
                buttonStates[key] = true;
                buttonCounts[key]++;
                totalCount++;
                updateTotalCount();
                
                // æ·»åŠ è§†è§‰åé¦ˆ
                const buttonElement = document.getElementById(`button-${gamepadIndex}-${buttonIndex}`);
                if (buttonElement) {
                    buttonElement.classList.add('pressed');
                    setTimeout(() => {
                        buttonElement.classList.remove('pressed');
                    }, 200);
                }
            } else if (!isPressed && buttonStates[key]) {
                buttonStates[key] = false;
            }
        }

        // æ›´æ–°æ€»è®¡æ•°æ˜¾ç¤º
        function updateTotalCount() {
            document.getElementById('totalCount').textContent = totalCount;
        }

        // æ¸²æŸ“æ‰‹æŸ„ç•Œé¢
        function renderGamepads() {
            const container = document.getElementById('gamepads');
            container.innerHTML = '';

            const gamepadList = navigator.getGamepads();
            
            for (let i = 0; i < gamepadList.length; i++) {
                const gamepad = gamepadList[i];
                if (!gamepad) continue;

                const gamepadDiv = document.createElement('div');
                gamepadDiv.className = 'gamepad';

                // æŒ‰æŒ‰é’®ç±»å‹åˆ†ç»„
                const buttonGroups = {
                    default: { title: 'Buttons æŒ‰é’®', buttons: [] }
                };

                gamepad.buttons.forEach((button, buttonIndex) => {
                    const buttonInfo = getButtonInfo(buttonIndex);
                    const key = `${gamepad.index}-${buttonIndex}`;
                    
                    // ç¡®ä¿åˆå§‹åŒ–è®¡æ•°
                    if (!(key in buttonCounts)) {
                        buttonCounts[key] = 0;
                    }
                    
                    const count = buttonCounts[key];
                    
                    buttonGroups.default.buttons.push({
                        index: buttonIndex,
                        name: buttonInfo.name,
                        type: buttonInfo.type,
                        count: count
                    });
                });

                let buttonsHTML = '';
                for (const [groupType, group] of Object.entries(buttonGroups)) {
                    if (group.buttons.length > 0) {
                        buttonsHTML += `
                            <div class="button-group">
                                <div class="button-group-title">${group.title}</div>
                                <div class="buttons-container">
                                    ${group.buttons.map(btn => `
                                        <div class="button-circle ${btn.type}" id="button-${gamepad.index}-${btn.index}">
                                            <div class="button-name">${btn.name}</div>
                                            <div class="button-count">${btn.count}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }

                gamepadDiv.innerHTML = `
                    <div class="gamepad-title">
                        ğŸ® ${gamepad.id} Idex ç´¢å¼•: ${gamepad.index}
                    </div>
                    ${buttonsHTML}
                    <div class="axes-section">
                        <h4>Axes æ‘‡æ†è½´</h4>
                        <div class="axes-grid">
                            ${gamepad.axes.map((axis, axisIndex) => `
                                <div class="axis-item">
                                    <div class="axis-name">${getAxisName(axisIndex)}</div>
                                    <div class="axis-value" id="axis-${gamepad.index}-${axisIndex}">${axis.toFixed(3)}</div>
                                    <div class="axis-bar">
                                        <div class="axis-center-line"></div>
                                        <div class="axis-indicator" id="axis-bar-${gamepad.index}-${axisIndex}"></div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                container.appendChild(gamepadDiv);
            }
        }

        // ä¸»å¾ªç¯ - æŒç»­æ£€æµ‹æ‰‹æŸ„çŠ¶æ€
        function gameLoop() {
            const gamepadList = navigator.getGamepads();
            let needsRender = false;
            
            for (let i = 0; i < gamepadList.length; i++) {
                const gamepad = gamepadList[i];
                if (!gamepad) continue;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ‰‹æŸ„
                if (!gamepads[gamepad.index]) {
                    gamepads[gamepad.index] = true;
                    needsRender = true;
                }

                // æ£€æµ‹æŒ‰é’®çŠ¶æ€
                gamepad.buttons.forEach((button, buttonIndex) => {
                    const isPressed = button.pressed || button.value > 0.5;
                    checkButtonPress(gamepad.index, buttonIndex, isPressed);
                });

                // æ›´æ–°è½´æ˜¾ç¤º
                gamepad.axes.forEach((axis, axisIndex) => {
                    const axisElement = document.getElementById(`axis-${gamepad.index}-${axisIndex}`);
                    if (axisElement) {
                        axisElement.textContent = axis.toFixed(3);
                    }
                    
                    // æ›´æ–°è½´æ¡æ˜¾ç¤º
                    const axisBarElement = document.getElementById(`axis-bar-${gamepad.index}-${axisIndex}`);
                    if (axisBarElement) {
                        // å°†è½´å€¼(-1åˆ°1)è½¬æ¢ä¸ºä½ç½®(0%åˆ°94%)ï¼Œç•™å‡ºæŒ‡ç¤ºå™¨é«˜åº¦ç©ºé—´
                        const position = ((axis + 1) / 2) * 94; // 0-94%
                        axisBarElement.style.top = `${position}%`;
                    }
                });

                // æ›´æ–°æŒ‰é’®è®¡æ•°æ˜¾ç¤º
                gamepad.buttons.forEach((button, buttonIndex) => {
                    const key = `${gamepad.index}-${buttonIndex}`;
                    const count = buttonCounts[key] || 0;
                    const countElement = document.querySelector(`#button-${gamepad.index}-${buttonIndex} .button-count`);
                    if (countElement) {
                        countElement.textContent = count;
                    }
                });
            }

            if (needsRender) {
                renderGamepads();
            }

            updateStatus();
            requestAnimationFrame(gameLoop);
        }

        // å¤ä½æ‰€æœ‰è®¡æ•°
        function resetAllCounts() {
            buttonCounts = {};
            buttonStates = {};
            totalCount = 0;
            updateTotalCount();
            renderGamepads();
        }

        // å¤ä½å½“å‰æ‰‹æŸ„è®¡æ•°
        function resetCurrentGamepad() {
            const gamepadList = navigator.getGamepads();
            const connectedGamepads = Array.from(gamepadList).filter(gp => gp !== null);
            
            if (connectedGamepads.length === 0) {
                alert('No gamepad connected æ²¡æœ‰è¿æ¥çš„æ‰‹æŸ„');
                return;
            }

            if (connectedGamepads.length === 1) {
                const gamepad = connectedGamepads[0];
                // å¤ä½è¿™ä¸ªæ‰‹æŸ„çš„æ‰€æœ‰æŒ‰é’®è®¡æ•°
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const key = `${gamepad.index}-${i}`;
                    const oldCount = buttonCounts[key] || 0;
                    buttonCounts[key] = 0;
                    buttonStates[key] = false;
                    totalCount -= oldCount;
                }
                totalCount = Math.max(0, totalCount);
                updateTotalCount();
                renderGamepads();
            } else {
                // å¤šä¸ªæ‰‹æŸ„ï¼Œè®©ç”¨æˆ·é€‰æ‹©
                let gamepadIndex = prompt(`Detected ${connectedGamepads.length} gamepads, enter gamepad index to reset (0-${connectedGamepads.length-1}) (æ£€æµ‹åˆ° ${connectedGamepads.length} ä¸ªæ‰‹æŸ„ï¼Œè¯·è¾“å…¥è¦å¤ä½çš„æ‰‹æŸ„ç´¢å¼• (0-${connectedGamepads.length-1})):`);
                gamepadIndex = parseInt(gamepadIndex);
                
                if (isNaN(gamepadIndex) || gamepadIndex < 0 || gamepadIndex >= gamepadList.length) {
                    alert('Invalid gamepad index æ— æ•ˆçš„æ‰‹æŸ„ç´¢å¼•');
                    return;
                }

                const gamepad = gamepadList[gamepadIndex];
                if (!gamepad) {
                    alert('Gamepad at this index is not connected è¯¥ç´¢å¼•çš„æ‰‹æŸ„æœªè¿æ¥');
                    return;
                }

                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const key = `${gamepadIndex}-${i}`;
                    const oldCount = buttonCounts[key] || 0;
                    buttonCounts[key] = 0;
                    buttonStates[key] = false;
                    totalCount -= oldCount;
                }
                totalCount = Math.max(0, totalCount);
                updateTotalCount();
                renderGamepads();
            }
        }

        // å¯åŠ¨ä¸»å¾ªç¯
        updateStatus();
        renderGamepads();
        gameLoop();
    </script>
</body>
</html>